<html>
<head>
    <script src='../zengine.js'></script>
    <script src='https://git.io/perlin.js'></script>
    <style>
    body {
        margin: 0;
        padding: 0;
    }
    #cnvs {
        background-color: black; 
        position: fixed;
        float: top;
        z-index: -1;
    }
    #lets_cont{
        padding: 10px;
        width: 200px;
    }
    p {
        text-align: center;
    }
    p, pre {
        font-family: monospace;
        margin: 0;
        color: white;
    }
    input {
        margin: 0;
        width: 100%;
    }
    button {
        margin: 0;
        width: 100%;
    }
    </style>
</head>

<body>

<canvas id='cnvs'></canvas>
<p id='cam'></p>
<div id='lets_cont'>
<p id='p_cells'>hills: 2</p>
<input min='0' value='2' max='10' type='range' oninput="document.getElementById('p_cells').innerText='hills: '+this.value;cells=parseInt(this.value);init();"></input>
<p id='p_width'>width: 32</p>
<input min='1' value='32' max='100' type='range' oninput="document.getElementById('p_width').innerText='width: '+this.value;grid.width=parseInt(this.value);init();"></input>
<p id='p_length'>length: 16</p>
<input min='1' value='16' max='100' type='range' oninput="document.getElementById('p_length').innerText='length: '+this.value;grid.length=parseInt(this.value);init();"></input>
<p id='p_height'>hill height: 4</p>
<input min='0' value='4' max='20' type='range' oninput="document.getElementById('p_height').innerText='hill height: '+this.value;hill_height=parseInt(this.value);init();"></input>
<p id='p_speed'>speed: 100</p>
<input min='1' value='100' max='200' type='range' oninput="document.getElementById('p_speed').innerText='speed: '+this.value;speed=parseInt(this.value);"></input>
</div>


<script>
'use strict';
let cnvs = document.getElementById('cnvs');
let ctx = cnvs.getContext('2d');

let grid = {width: 32, length: 16};
let cells = 2;
let hill_height = 4;
let speed = 100;
let scrolling = false;
let wireframe = false;
let cam = {yaw: 0,
           pitch: -30,
           roll: 0,
           fov: 80};
let heights;
let row_shift;

//resizes canvas to fill full screen
function fit_to_screen(){
    cnvs.width = innerWidth;
    cnvs.height = innerHeight;
}
fit_to_screen();
window.addEventListener('resize', fit_to_screen);

init();
update();

//returns an array of faces (triangles) that follow the surface described by the array of heights
function gen_world(){
    let world = [];
    for (let r = 0; r < grid.length; r++){
        for (let c = 0; c < grid.width; c++){
            //`v` is just a scaled version of the height of this triangle for its colour
            let v = parseInt((heights[r][c] / hill_height) * 360 + 180);
            let col = 'hsl(' + v + ',40%,60%)';
            /* format for tile (two triangles):
             *   [2] (c,r+1) *---* (c+1,r+1) [3]
             *               | \ |
             *   [0]   (c,r) *---* (c+1,r)   [1]
             */
            let vs = [{x: c,   y: r,   z: heights[r  ][c  ]},
                      {x: c+1, y: r,   z: heights[r  ][c+1]},
                      {x: c,   y: r+1, z: heights[r+1][c  ]},
                      {x: c+1, y: r+1, z: heights[r+1][c+1]}];
            //gives vector betweent two points
            let vec = (p1, p2) => ({x: p2.x-p1.x, y: p2.y-p1.y, z: p2.z-p1.z});
            world.push(
                {verts: [vs[0], vs[1], vs[2]],
                 vect: zengine.cross_prod(vec(vs[0],vs[1]), vec(vs[0],vs[2])),
                 col: col},
                {verts: [vs[1], vs[2], vs[3]],
                 vect: zengine.cross_prod(vec(vs[3],vs[2]), vec(vs[3],vs[1])),
                 col: col}
            );
        }
    }
    return world;
}

//removes first row from heights array and pushes the next one to the end
function shift_heights_arr(){
    heights.shift(1);
    heights.push(get_row(row_shift++));
}

//get row using perlin.js lib at index: ind
function get_row(ind){
    let row = [];
    for (let c = 0; c < grid.width + 1; c++){
        row.push(perlin.get(c * (cells/Math.min(grid.width, grid.length)),
                          ind * (cells/Math.min(grid.width, grid.length))) * hill_height);
    }
    return row;
}

//initialises heights array using perlin.js lib and resets/centres cam
function init(){
    perlin.seed();
    heights = [];
    for (row_shift = 0; row_shift < grid.length + 1; row_shift++){
        heights.push(get_row(row_shift));
    }
    cam.x = grid.width/2;
    cam.y = -20;
    cam.z = 20;
}

//handles the update to the next frame
function update(){
    shift_heights_arr();
    zengine.render(gen_world(), cam, cnvs, wireframe);
    requestAnimationFrame(update);
    //setTimeout(update, speed);
}
</script>
</body>
</head>
